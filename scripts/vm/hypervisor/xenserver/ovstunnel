#!/usr/bin/python
# Version @VERSION@
#
# A plugin for executing script needed by vmops cloud 

import os, sys, time
import subprocess
import XenAPIPlugin
sys.path.append("/opt/xensource/sm/")
import util
from util import CommandException
import hostvmstats
import socket
import stat
import base64
import tempfile
from os.path import exists as _exists
from time import localtime as _localtime, asctime as _asctime

vSwitchDBPidFile = "/var/run/openvswitch/ovsdb-server.pid"
vSwitchDBDaemonName = "ovsdb-server"
vSwitchPidFile = "/var/run/openvswitch/ovs-vswitchd.pid"
vsctlPath = "/usr/bin/ovs-vsctl"
ofctlPath = "/usr/bin/ovs-ofctl"
xePath=  "/opt/xensource/bin/xe"
vSwitchDaemonName = "ovs-vswitchd"

logFile = "/var/log/ovstunnel.log"
fLog = None

def find_vifs_v5(xs_nw_uuid):
	pr("Fetching vifs on networks - for XS version 5.x")
	vif_uuids_cmd = [xePath, 'network-list', 'uuid=%s' %xs_nw_uuid,
					'params=VIF-uuids', '--minimal']
	vif_uuids_str = do_cmd(vif_uuids_cmd)
	vif_uuids = vif_uuids_str.split(';')
	vifs = []
	for vif_uuid in vif_uuids:
		vif_uuid = vif_uuid.strip()
		is_attached_cmd = [xePath, 'vif-list', 'uuid=%s' %vif_uuid,
					       'params=currently-attached', '--minimal']
		is_attached = do_cmd(is_attached_cmd)
		# Consider only attached VIFs
		if is_attached == 'false': 
			continue
		vm_uuid_cmd = [xePath, 'vif-list', 'uuid=%s' %vif_uuid,
					   'params=vm-uuid', '--minimal']
		vm_uuid = do_cmd(vm_uuid_cmd)
		dom_id_cmd = [xePath, 'vm-list', 'uuid=%s' %vm_uuid,
					  'params=dom-id', '--minimal']
		dom_id = do_cmd(dom_id_cmd)
		device_cmd = [xePath, 'vif-list', 'uuid=%s' %vif_uuid,
					  'params=device', '--minimal']
		device = do_cmd(device_cmd)
		vifs.append("vif%s.%s" % (dom_id, device))
	pr("Vifs on network:%s" %vifs)
	vif_ofports = []
	for vif in vifs:
		vif_ofport_cmd=[vsctlPath, 'get', 'interface', vif, 'ofport']
		vif_ofport = do_cmd(vif_ofport_cmd).strip()
		if vif_ofport.endswith('\n'):
			vif_ofport = vif_ofport[:-1]
		vif_ofports.append(vif_ofport)
	pr("Vif Ofports:%s" %vif_ofports)
	return vif_ofports


def find_vifs_v6(xs_nw_uuid):
	pr("Fetching vifs on networks - for XS version 6.x")
	cmd_vif_ofports = [vsctlPath, "--", "--columns=ofport",
					   "find", "interface",
					   "external_ids:xs-network-uuid=%s" % xs_nw_uuid,
					   "type!=gre"]
	vif_ofports_str = do_cmd(cmd_vif_ofports)
	vif_ofports = []
	for line in vif_ofports_str.split('\n'):
			elements = line.split(':')
			if len(elements)==2:
				# ensure no trailing \n is returned
				if elements[1].endswith('\n'):
					elements[1] = elements[1][:-1]
				vif_ofports.append(elements[1])
	pr("Vif ofports:%s" %vif_ofports)
	return vif_ofports

vif_ofport_list_handlers = {
	'5': find_vifs_v5,
	'6': find_vifs_v6}

class PluginError(Exception):
	"""Base Exception class for all plugin errors."""
	def __init__(self, *args):
		Exception.__init__(self, *args)


def echo(fn):
	def wrapped(*v, **k):
		name = fn.__name__
		util.SMlog("#### VMOPS enter  %s ####" % name )
		res = fn(*v, **k)
		util.SMlog("#### VMOPS exit  %s ####" % name )
		pr("%s is about to return the following:%s" %(name,res))
		return res
	return wrapped

def open_log ():
	global fLog

	try:
		if fLog == None:
			fLog = open (logFile, "a")
	except IOError, e:
		#print e
		pass

def pr (str):
	global fLog

	if fLog != None:
		str = "[%s]:" % _asctime (_localtime()) + str + "\n"
		fLog.write (str)

def close_log ():
	global fLog

	if fLog != None:
		fLog.close ()

def is_process_run (pidFile, name):
	try:
		fpid = open (pidFile, "r")
		pid = fpid.readline ()
		fpid.close ()
	except IOError, e:
		return -1

	pid = pid[:-1]
	ps = os.popen ("ps -ae")
	for l in ps:
		if pid in l and name in l:
			ps.close ()
			return 0

	ps.close ()
	return -2

def is_tool_exist (name):
	if _exists (name):
		return 0
	return -1


def check_switch ():
	global result

	ret = is_process_run (vSwitchDBPidFile, vSwitchDBDaemonName);
	if ret < 0:
		if ret == -1: return "NO_DB_PID_FILE"
		if ret == -2: return "DB_NOT_RUN"

	ret = is_process_run (vSwitchPidFile, vSwitchDaemonName)
	if ret < 0:
		if ret == -1: return "NO_SWITCH_PID_FILE"
		if ret == -2: return "SWITCH_NOT_RUN"

	#TODO (salvatore-orlando): Think about remotely executing ovs-vsctl
	#and ovs-ofctl in the future 
	if is_tool_exist (vsctlPath) < 0:
		return "NO_VSCTL"

	if is_tool_exist (ofctlPath) < 0:
		return "NO_OFCTL"

	return "SUCCESS"


def do_cmd(cmd):
	"""Abstracts out the basics of issuing system commands. If the command
	returns anything in stderr, a PluginError is raised with that information.
	Otherwise, the output from stdout is returned.
	"""

	pipe = subprocess.PIPE
	pr("Executing:%s" %cmd)
	proc = subprocess.Popen(cmd, shell=False, stdin=pipe, stdout=pipe, stderr=pipe, close_fds=True)
	ret_code = proc.wait()
	err = proc.stderr.read()
	if ret_code:
		pr("The command exited with the error code: %s (stderr output:%s)" 
			% (ret_code, err))
		raise PluginError(err)
	output = proc.stdout.read()
	if output.endswith('\n'):
		output = output[:-1]
	return output


######################## GRE creation utils ##########################
# UUID's format is 8-4-4-4-12
def is_uuid (uuid):
	list = uuid.split ("-")

	if len (list) != 5:
		return -1

	if len (list[0]) != 8 or len (list[1]) != 4 \
	   or len (list[2]) != 4 or len (list[3]) != 4 \
	   or len (list[4]) != 12:
		   return -1

	return 0

@echo
def setup_ovs_bridge(session, args):
	bridge = args.pop("bridge")
	key = args.pop("key")
	
	res = check_switch()
	if res != "SUCCESS":
		return "FAILURE:%s" %res

	pr("About to manually create the following bridge:%s" %bridge)
	# create a bridge with the same name as the xapi network
	# also associate gre key in other config attribute
	res = do_cmd([vsctlPath, "--", "--may-exist", "add-br", bridge, "--", "set",
				  "bridge", bridge, "other_config:gre_key=%s" % key])
	pr("Bridge has been manually created:%s" %res)
	# TODO: Make sure xs-network-uuid is set into external_ids
	# Non empty result means something went wrong
	if res:
		result = "FAILURE:%s" %res
	else:
		# Verify the bridge actually exists, with the gre_key properly set
		res = do_cmd([vsctlPath, "get", "bridge", bridge, "other_config:gre_key"])
		if key in res:
			result = "SUCCESS:%s" %bridge 
		else:
			result = "FAILURE:%s" %res
	pr("Setup_ovs_bridge complete with result:%s" %result)
	return result
	
@echo
def destroy_ovs_bridge(session, args):#
	bridge = args.pop("bridge")

	res = check_switch()
	if res != "SUCCESS":
		return res

	
@echo
def create_tunnel(session, args):
	bridge = args.pop("bridge")
	remote_ip = args.pop("remote_ip")
	gre_key = args.pop("key")
	src_host = args.pop("from")
	dst_host = args.pop("to")
	
	pr("Entering create_tunnel")
	
	res = check_switch()
	if res != "SUCCESS":
		pr("Openvswitch running: NO")
		return "FAILURE:%s" %res
	pr("Openvswitch running: OK")
	
	# We need to keep the name below 14 characters
	# src and target are enough - consider a fixed length hash
	name = "t%s-%s-%s" % (gre_key, src_host, dst_host)
	
	# Verify the xapi bridge to be created
	# NOTE: Timeout should not be necessary anymore
	wait = [vsctlPath, "--timeout=30", "wait-until", "bridge", bridge, "--",
		    "get", "bridge", bridge, "name"]
	res = do_cmd(wait)
	if bridge not in res:
		pr("WARNING:Can't find bridge %s for creating tunnel!" % bridge)
		return "FAILURE:NO_BRIDGE"
	pr("bridge %s for creating tunnel - VERIFIED" % bridge)
	tunnel_setup = False
	drop_flow_setup = False
	try:
		# Create a port and configure the tunnel interface for it
		add_tunnel = [vsctlPath, "add-port", bridge, name, "--", "set", "interface",
					name, "type=gre", "options:key=%s" % gre_key,
					"options:remote_ip=%s" % remote_ip] 
		do_cmd(add_tunnel)
		tunnel_setup = True
		# verify port
		verify_port = [vsctlPath, "get", "port", name, "interfaces"]
		res = do_cmd(verify_port)
		# Expecting python-style list as output
		iface_list = []
		pr("RESULT FROM IFACE LIST:%s" %res)
		if len(res) > 2:
			iface_list = res.strip()[1:-1].split(',')
		if len(iface_list) != 1:
			pr("WARNING: Unexpected output while verifying port %s on bridge %s" %(name, bridge))
			return "FAILURE:VERIFY_PORT_FAILED"
		
		# verify interface
		iface_uuid = iface_list[0]
		verify_interface_key = [vsctlPath, "get", "interface", iface_uuid, "options:key"]
		verify_interface_ip = [vsctlPath, "get", "interface", iface_uuid, "options:remote_ip"]
		
		key_validation = do_cmd(verify_interface_key)
		ip_validation = do_cmd(verify_interface_ip)
		
		if not gre_key in key_validation or not remote_ip in ip_validation:
			pr("WARNING: Unexpected output while verifying interface %s on bridge %s" %(name, bridge))
			return "FAILURE:VERIFY_INTERFACE_FAILED"
		pr("Tunnel interface validated:%s" %verify_interface_ip)
		cmd_tun_ofport = [vsctlPath, "get", "interface", iface_uuid, "ofport"]
		tun_ofport = do_cmd(cmd_tun_ofport)
		# Ensure no trailing LF
		if tun_ofport.endswith('\n'):
			tun_ofport = tun_ofport[:-1]
		# add flow entryies for dropping broadcast coming in from gre tunnel
		pr("TUNNEL OFPORT:%s" %tun_ofport)
		add_flow(bridge, priority=1000, in_port=tun_ofport,
				dl_dst='ff:ff:ff:ff:ff:ff', actions='drop')
		add_flow(bridge, priority=1000, in_port=tun_ofport,
				nw_dst='224.0.0.0/24', actions='drop')
		drop_flow_setup = True
		pr("Broadcast drop rules added")
		# add flow entry for allowing broadcast to reach ports already configured on OVS bridge
		cmd_xs_nw_uuid = [xePath, "network-list",
						  "bridge=%s" % bridge, "--minimal"]
		pr("HERE-1")
		xs_nw_uuid = do_cmd(cmd_xs_nw_uuid)
		pr("HERE-2")
				
		host_list_cmd = [xePath, 'host-list', '--minimal']
		host_list_str = do_cmd(host_list_cmd)
		# need only first host
		pr("HERE-3")
		host_uuid = host_list_str.split(',')[0].strip()
		"""
		version_cmd = [xePath, 'host-param-get', 'uuid=%s' % host_uuid,
					   'param-name=software-version', 'param-key=product_version']
		version = do_cmd(version_cmd)
		pr ("HERE-4")
		vif_ofports = vif_ofport_list_handlers[version[0]](xs_nw_uuid)
		pr("HERE-5")
		if len(vif_ofports) > 0:
			action = "".join("output:%s," %ofport for ofport in vif_ofports)[:-1]
			pr("HERE-5")
			add_flow(bridge, priority=1100, in_port=tun_ofport,
					dl_dst='ff:ff:ff:ff:ff:ff', actions=action)
			add_flow(bridge, priority=1100, in_port=tun_ofport,
					nw_dst='224.0.0.0/24', actions=action)
		pr("HERE-6")
		"""
		return "SUCCESS:%s" % name
	except:
		pr("An unexpected error occured. Rolling back")
		if tunnel_setup:
			pr("Deleting GRE interface")
			# Destroy GRE port and interface
			del_port(bridge, name)
		if drop_flow_setup:
			# Delete flows
			pr("Deleting flow entries from GRE interface")
			del_flows(bridge, tun_ofport)
		pr("About to re-raise - %s -%s" % (sys.exc_info()[0], sys.exc_info()[1]))
		raise
######################## End GRE creation utils ##########################

def del_all_flows(bridge):
	delFlow = [ofctlPath, "del-flows %s" % bridge]
	do_cmd(delFlow)

	normalFlow = "priority=0 idle_timeout=0 hard_timeout=0 actions=normal"
	add_flow(bridge, normalFlow)

def del_flows(bridge, ofport):
	""" removes flows configured for a specific of ports """
	delFlow = [ofctlPath, 'del-flows', bridge, 'in_port=%s' % ofport]
	do_cmd(delFlow)

def del_port(bridge, port):
	delPort = [vsctlPath, "del-port", bridge, port]
	do_cmd(delPort)

@echo
def destroy_tunnel(session, args):
	bridge = args.pop("bridge")
	inPort = args.pop("in_port")

	# delete all gre ports on bridge
	if inPort == "[]":
		listPorts = [vsctlPath, "list-ports %s" % bridge]
		res = do_cmd(listPorts, True)
		for p in res:
			if bridge in p:
				del_port(bridge, p)
		del_all_flows(bridge)
	else:
		ofport = get_field_of_interface(inPort, "ofport")
		del_flows(bridge, ofport)
		del_port(bridge, inPort)

	return "SUCCESS"

def get_field_of_interface(nameOruuid, field):
	listIface = [vsctlPath, "list interface", nameOruuid]
	res = do_cmd(listIface, True)

	for i in res:
		if field in i:
			(x, r) = i.split(":")
			return r.lstrip().rstrip()
	return None


def add_flow(bridge, **kwargs):
	"""
	Builds a flow expression for **kwargs and adds the flow entry
	to an Open vSwitch instance
	"""
	pr("I am in add_flow")
	flow = "hard_timeout=%s,idle_timeout=%s,priority=%s"\
			% (kwargs.get('hard_timeout','0'),
			   kwargs.get('idle_timeout','0'),
			   kwargs.get('priority','1'))
	in_port = 'in_port' in kwargs and ",in_port=%s" % kwargs['in_port'] or ''
	dl_src = 'dl_src' in kwargs and ",dl_src=%s" % kwargs['dl_src'] or ''
	dl_dst = 'dl_dst' in kwargs and ",dl_dst=%s" % kwargs['dl_dst'] or ''
	nw_src = 'nw_src' in kwargs and ",nw_src=%s" % kwargs['nw_src'] or ''
	nw_dst = 'nw_dst' in kwargs and ",nw_dst=%s" % kwargs['nw_dst'] or ''
	ip = ('nw_src' in kwargs or 'nw_dst' in kwargs) and ',ip' or ''
	actions = 'actions' in kwargs and ",actions=%s" % kwargs['actions'] or ''
	flow = flow + in_port + dl_src + dl_dst + ip + nw_src + nw_dst + actions
	pr("Flow to add:%s" %flow)
	addflow = ["ovs-ofctl", "add-flow", bridge, flow]
	do_cmd(addflow)
	pr("Flow added")

if __name__ == "__main__":
	open_log()
	XenAPIPlugin.dispatch({"create_tunnel":create_tunnel, 
						   "destroy_tunnel":destroy_tunnel,
						   "setup_ovs_bridge": setup_ovs_bridge,
						   "destroy_ovs_bridge": destroy_ovs_bridge})
	close_log()

